/*+********************************************************************************
 * The contents of this file are subject to the vtiger CRM Public License Version 1.0
 * ("License"); You may not use this file except in compliance with the License
 * The Original Code is:  vtiger CRM Open Source
 * The Initial Developer of the Original Code is vtiger.
 * Portions created by vtiger are Copyright (C) vtiger.
 * All Rights Reserved.
 ********************************************************************************/

function cbCWMTask($) {
	let vtinst = new VtigerWebservices('webservice.php');
	let accessibleModulesInfo = null;
	let cbGroups = null;
	let map = fn.map;
	let dict = fn.dict;
	let filter = fn.filter;
	let reduceR = fn.reduceR;
	let parallelExecuter = fn.parallelExecuter;
	let contains = fn.contains;
	let concat = fn.concat;

	function diff(reflist, list) {
		let out = [];
		$.each(list, function (i, v) {
			if (contains(reflist, v)) {
				out.push(v);
			}
		});
		return out;
	}

	//Display an error message.
	function errorDialog(message) {
		alert(message);
	}

	//This is a wrapper to handle webservice errors.
	function handleError(fn) {
		return function (status, result) {
			if (status) {
				fn(result);
			} else {
				errorDialog('Failure:'+result);
			}
		};
	}

	//Insert text at the cursor
	function insertAtCursor(element, value) {
		//http://alexking.org/blog/2003/06/02/inserting-at-the-cursor-using-javascript
		if (document.selection) {
			element.focus();
			const sel = document.selection.createRange();
			sel.text = value;
			element.focus();
		} else if (element.selectionStart || element.selectionStart == '0') {
			let startPos = element.selectionStart;
			let endPos = element.selectionEnd;
			let scrollTop = element.scrollTop;
			element.value = element.value.substring(0, startPos) + value + element.value.substring(endPos, element.value.length);
			element.focus();
			element.selectionStart = startPos + value.length;
			element.selectionEnd = startPos + value.length;
			element.scrollTop = scrollTop;
		} else {
			element.value += value;
			element.focus();
		}
	}

	// Convert user type into reference for consistency in describe objects
	// This is done in place
	function referencify(desc) {
		for (const element of desc['fields']) {
			let type = element['type'];
			if (type['name']=='owner') {
				type['name']='reference';
				type['refersTo']=['Users'];
			}
		}
		return desc;
	}

	// Return an array containing the description of a module and all modules reffered by it. This is passed to callback.
	function getDescribeObjects(accessibleModules, moduleName, callback) {
		vtinst.describeObject(moduleName, handleError(function (result) {
			let parent = referencify(result);
			let fields = parent['fields'];
			let referenceFields = filter(
				function (e) {
					return e['type']['name']=='reference';
				},
				fields
			);
			let referenceFieldModules = map(
				function (e) {
					return e['type']['refersTo'];
				},
				referenceFields
			);
			function union(a, b) {
				let newfields = filter(
					function (e) {
						return !contains(a, e);
					},
					b
				);
				return a.concat(newfields);
			}
			let relatedModules = reduceR(union, referenceFieldModules, [parent['name']]);

			// Remove modules that is no longer accessible
			relatedModules = diff(accessibleModules, relatedModules);

			function executer(parameters) {
				let failures = filter(function (e) {
					return e[0]==false;
				}, parameters);
				if (failures.length!=0) {
					callback(false, failures[0][1]);
				} else {
					let moduleDescriptions = map(
						function (e) {
							return referencify(e[1]);
						},
						parameters
					);
					let modules = dict(map(
						function (e) {
							return [e['name'], e];
						},
						moduleDescriptions
					));
					callback(true, modules);
				}
			}
			let p = parallelExecuter(executer, relatedModules.length);
			$.each(relatedModules, function (i, v) {
				p(function (callback) {
					vtinst.describeObject(v, callback);
				});
			});
		}));
	}

	function fillSelectBox(id, modules, parentModule, filterPred) {
		if (filterPred==null) {
			filterPred = function () {
				return true;
			};
		}
		let parent = modules[parentModule];
		let fields = parent['fields'];

		function filteredFields(fields) {
			return filter(
				function (e) {
					let fieldCheck = !contains(['autogenerated', 'reference', 'owner', 'multipicklist', 'password'], e.type.name);
					let predCheck = filterPred(e);
					return fieldCheck && predCheck;
				},
				fields
			);
		}
		let parentFields = map(
			function (e) {
				return [e['name'], e['label']];
			},
			filteredFields(parent['fields'])
		);

		let referenceFieldTypes = filter(
			function (e) {
				return (e['type']['name']=='reference');
			},
			parent['fields']
		);

		let moduleFieldTypes = {};
		$.each(modules, function (k, v) {
			moduleFieldTypes[k] = dict(map(function (e) {
				return [e['name'], e['type']];
			}, filteredFields(v['fields'])));
		});

		function getFieldType(fullFieldName) {
			let fieldModule = moduleName;
			let fieldName = fullFieldName;
			let group = fullFieldName.match(/(\w+) : \((\w+)\) (\w+)/);
			if (group!=null) {
				fieldModule = group[2];
				fieldName = group[3];
			}
			return moduleFieldTypes[fieldModule][fieldName];
		}

		function fieldReferenceNames(referenceField) {
			let name = referenceField['name'];
			let label = referenceField['label'];
			function forModule(moduleName) {
				// If module is not accessible return no field information
				if (!contains(accessibleModulesInfo, moduleName)) {
					return [];
				}
				return map(
					function (field) {
						return ['('+name+' : ('+moduleName+') '+field['name']+')', label+' : ('+modules[moduleName]['label']+') '+field['label']];
					},
					filteredFields(modules[moduleName]['fields'])
				);
			}
			return reduceR(concat, map(forModule, referenceField['type']['refersTo']), []);
		}

		let referenceFields = reduceR(concat, map(fieldReferenceNames, referenceFieldTypes), []);
		let fieldLabels = dict(parentFields.concat(referenceFields));
		let select = $('#'+id);
		let optionClass = id+'_option';
		$.each(fieldLabels, function (k, v) {
			select.append('<option class="'+optionClass+'" value="'+k+'">' + v + '</option>');
		});
		if (cbGroups != null) {
			$.each(cbGroups, function (k, v) {
				let plval = '(general : (__VtigerMeta__) groupEmailList_' + v.groupname.replace(' ', '_') + ')';
				select.append('<option class="'+optionClass+'" value="'+plval+'">' + v.groupname + '</option>');
			});
		}
		if (parentModule=='Events') {
			select.append('<option class="'+optionClass+'" value="(general : (__VtigerMeta__) Events_Users_Invited)">Invited Users</option>');
		}
	}

	$(document).ready(function () {
		vtinst.extendSession(handleError(function (result) {
			vtinst.query('select groupname from Groups;', function (resp, rdo) {
				if (resp) {
					cbGroups = rdo;
				}
			});
			vtinst.listTypes(handleError(function (accessibleModules) {
				accessibleModulesInfo = accessibleModules;

				getDescribeObjects(accessibleModules, moduleName, handleError(function (modules) {
					fillSelectBox('task-fieldnames', modules, moduleName);
					$('#task-fieldnames-busyicon').hide();
					$('#task-fieldnames').show();
					$('#task-fieldnames').change(function () {
						let textarea = CKEDITOR.instances.messageBody;
						let value = '$'+jQuery(this).val();
						textarea.insertHtml(value);
					});

					//time_changes
					$('#task_timefields').change(function () {
						let textarea = CKEDITOR.instances.messageBody;
						let value = '$'+$(this).val();
						textarea.insertHtml(value);
					});
				}));
			}));
		}));
	});
}
cbCWMTask = cbCWMTask(jQuery);
